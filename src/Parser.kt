package LSystems.Parser
import java.util.*

data class StackCommand(val push : Boolean, val pop : Boolean)
data class TurtleCommand(val rotation: Double, val forward : Double, val stackCommand : StackCommand)
/*  A data class for Turtle commands.
    Members:
        rotation : Double - The degree of rotation to apply
        forward : Double  - How many pixels to move forward
 */

data class Rule(val replacementChar : Char, val replacementString : String)
/*  A data class for production rules.
    Members:
        replacementChar : Char      - The character to replace in the string
        replacementString : String  - What to replace the replacementChar with.
 */

data class Meaning(val char : Char, val turtleCommand : TurtleCommand)
/*  A data class for meanings.
    Members:
        char : Char                     - The char to assign the given meaning to
        turtleCommand : TurtleCommand   - The meaning (command) to assign the char to
 */

class Parser(val text : String)
{
    /*  A parser for L-Systems. It's able to take basic production rules and meanings, and translate them into Turtle commands,
        to be fed into a Turtle graphics library (hopefully the one included).
        Args:
            text : String - The starting production rule.
     */

    fun generate(iterations : Int, rules : ArrayList<Rule>) : String
    {
        /*  Generates the final string, as according to the production rules.
            Args:
                iterations : Int        - How many times to apply the production rules
                rules : ArrayList<Rule> - A list of rules to apply.
            Returns:
                A String containing the generated text to pass into the parser.
         */

        var finalText : String = text
        for (i in 1..iterations)
        {
            var newText : String = ""
            for(c in finalText)
            {
                var wasReplaced : Boolean = false

                // Apply each rule possible to the given character.
                for(rule in rules)
                {
                    val (char, string) = rule

                    if (c == char)
                    {
                        wasReplaced = true
                        newText += string
                    }
                }

                // If no rule was applied, then no rule exists for it, and it should be kept in the string.
                if(!wasReplaced)
                {
                    newText += c
                }
            }
            finalText = newText
        }
        return finalText
    }

    fun parse(meanings : ArrayList<Meaning>, generatedText : String) : ArrayList<TurtleCommand>
    {
        /*  Parses the text that's been generated by generate into TurtleCommands as specified in the meanings for each character.
            Args:
                meanings : ArrayList<Meaning>   - A list of all meanings to apply
                generatedText : String          - The string returned from generate
            Returns:
                An ArrayList<TurtleCommand> containing each TurtleCommand to execute, in order to render the L-System.
         */

        var array = ArrayList<TurtleCommand>()
        for(c in generatedText)
        {
            for(meaning in meanings)
            {
                val char : Char             = meaning.char
                val command : TurtleCommand = meaning.turtleCommand
                if(c == char)
                {
                    array.add(command)
                    break
                }
            }
        }

        return array
    }
}

